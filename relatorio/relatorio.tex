%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.3 (9/9/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[twoside]{article}

\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}


%\usepackage{lipsum} % Package to generate dummy text throughout this template

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage{multicol} % Used for the two-column layout of the document
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{float} % Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{paralist} % Used for the compactitem environment which makes bullet points with less space between them

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\Roman{subsection}} % Roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{Relatorio EDA $\bullet$ Outubro 2013} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{\vspace{-15mm}\fontsize{24pt}{10pt}\selectfont\textbf{Comparando operações comuns em função do tempo em estruturas de dados avançadas}} % Article title

\author{
\large
\textsc{Carlos Mattoso, Gabriel Barros e Leonardo Kaplan
}\\[2mm] % Your name
\normalsize PUC-Rio \\ % Your institution
}
\date{}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Insert title

\thispagestyle{fancy} % All pages have headers and footers

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

\begin{abstract}

\noindent 
Nossa motivação ao desenvolver este projeto foi comparar as operações mais comuns (inserção, remoção e busca) em diferentes estruturas de dados avançadas a fim de determinar a mais eficiente em termos de tempo de execução.
As estruturas escolhidas foram tabelas Hash, Arvore Binária simples e Arvores Binárias balanceadas. 

\end{abstract}

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\begin{multicols}{2} % Two-column layout throughout the main article text

\section{Introdução}

\lettrine[nindent=0em,lines=3]{P}ara determinar a estrutura de dados mais eficiente em termos de velocidade de execução escolhemos representantes dos diversos paradigmas:
Tabelas hash, com diferentes tratamentos de colisão; Arvores de busca binaria simples e Arvores de busca balanceadas.
Para comparar as diferentes estruturas comparamos os tempos de inserção, remoção e busca nas estruturas em 2 tipos diferentes de entradas:
- Uma com várias operações de inserção (possivelmente de valores já inseridos)
- Outra com as mesmas inserções, seguidas de operações de busca, remoção e até inserção. 
Era esperado que a Hash de passo unitário fosse a mais rápida em todas as entradas, destacando-se principalmente em busca. 


%------------------------------------------------

\section{Hash Tables}


Variamos as tabelas Hash em função do tratamento de colisão, aplicando:

\subsection{ Passo fixo unitário }
    Aqui, ao inserirmos verificamos se a posição dada pela função Hash está livre e, caso esteja, inserimos o elemento; em caso de colisão, verificamos a posição seguinte e assim em diante até encontrar algum bucket vazio. Na inserção garantimos que não ocorrerá inserção de duplicatas.
    No caso da busca, segue-se o mesmo processo, comparando-se o elemento candidato ao que estamos buscando e se forem iguais, a busca foi bem sucedida. Caso atinja-se uma posição vazia indica-se que o elemento não encontra-se na árvore.
    Finalmente, para a remoção é necessária uma operação mais custosa. Caso o elemento a ser removido encontre-se na tabela, é necessário reinserir, caso exista, a sequência contínua de elementos que vem imediatamente após o removido.

\subsection{ Hashing duplo, definindo o tamanho do passo com outro hash }
   Os procedimentos aqui são bem parecidos ao tipo anterior. No caso da inserção a diferença é que percorre-se a tabela com um passo definido por uma outra hash function. Também, por utilizarmos remoção "lazy" neste caso (afinal, não seria fácil achar quem pode ter colidido com o elemento a ser removido), a inserção é quem esvazia posições marcadas como removidas substituindo-nas pelo novo elemento. A inserção continua garantindo que elementos que tenham uma cópia na tabela não serão inseridos.
   A busca segue os mesmos passos que no tipo anterior, com a diferença do passo.
   Finalmente, a remoção como já dito é feita de modo "lazy", só ocorrendo de fato na inserção.

\subsection{ Encadeamento externo através de lista encadeada }
   Neste método, cada bucket da tabela é uma lista encadeada. Assim, caso ocorra alguma colisão basta inserir na lista. 
   A busca neste caso deve ser feita passando-se por cada elemento da lista encadeada.
   Finalmente, a remoção de fato ocorre caso o elemento encontre-se em sua respectiva lista.

Em todos os casos a tabela Hash foi representada como um grande vetor de ponteiros para strings que representavam os conjuntos lidos. Embora esta representação tenha exigido comparação de strings, uma operação não muito eficiente, isto não afeta o resultado dos testes pois teve de ser feito para todas as estruturas. 

Adotamos duas estratégias para minimizar o número de colisões:
\begin{compactitem}
\item Uso de boas funções de hash para string: 
   fnv1a e djb2, testadas por muitos pesquisadores e em aplicações do mundo real. Ambas garantem uma distribuição de qualidade satisfatória, minimizando significativamente o número de colisões.

\item Criação de tabelas de tamanho mais que o suficiente:
   Como sabemos desde o início a quantidade de elementos máxima que leríamos, podemos criar uma tabela de tamanho maior até mesmo que o necessário, reduzindo as chances de ocorrência de colisões. Em razão disto não tivemos que implementar algoritmos de ajuste de tamanho da tabela, no caso de ela não conseguir comportar mais elementos ou ter atingido um fator de carga muito alto. De fato, numa aplicação de mundo real isto pode nem sempre ser possível.
\end{compactitem}



%------------------------------------------------


\section{Árvores}

No caso de árvores testamos dois tipos:
\subsection{ Árvore Binária de Busca Não Balanceada }
   Foi implementada através de ponteiros encadeados, pois a representação com array ficaria inviável em razão de seu despercídio de memória (afinal, a árvore pode ficar drasticamente degenerada). Os algoritmos de inserção, remoção e busca foram feitos de modo iterativo, a fim de se evitar a possibilidade de "stack overflow", devido ao grande número de elementos que seria inserido; como a árvore nunca é balanceada, poderíamos atingir níveis muito baixos.

\subsection{ AVL (ABB Balanceada) }
   A implementação de AVL por nós utilizada foi extraída de uma biblioteca popular chamada "libavl". Mais informações sobre ela encontram-se em: http://adtinfo.org/
   Utilizamos a versão simples, ensinada em sala de aula. O site apresenta também uma documentação detalhada que enuncia quais fragmentos de código executam uma determinada operação (como rotações). No caso de rebalanceamento, por exemplo, tais informações encontram-se aqui: 
   http://adtinfo.org/libavl.html/Rebalancing-AVL-Trees.html

\subsection{ Árvore B }
   Não conseguimos encontrar uma implementação que fosse bem documentada e permitisse customizar os parâmetros da árvore.


%-----------------------------------------------------------------------
\section{Análise dos resultados}
	Os testes foram executados em uma máquina com Intel i7 com clock travado em 0.77 GHz com 4 Gb de RAM.
	A análise foi feita sobre os resultados em anexo.%Ou na seção 4, resultados.
	No quesito inserção a estrutura mais rápida foi o Hash simples, como esperado, pois só necessita de um passo para os casos de colisão, enquanto o hash duplo seguiu como o segundo melhor, já que para colisões ele roda um operação de hash a mais. Por fim, o hash de listas encadeadas foi o pior, pois necessita de operações de realocação de memória para resolução de colisão, além disso, vale mencionar que as funções do módulo hash de listas encadeadas utiliza um módulo externo de listas encadeadas, o que influencia negativamente no seu desempenho.
	No quesito busca

%-----------------------------------------------------
\section{Results}

\begin{table}[H]
\caption{bst}
\centering
\begin{tabular}{llr}
\toprule
\multicolumn{2}{c}{BST} \\
\cmidrule(r){2}
Inserção & Remoção & Busca \\
\cmidrule(r){2}
Média & Total & Média & Total & Média & Total\\
\midrule
John & Doe & $7.5$ & Richard & Miles & $2$ \\
\bottomrule
\end{tabular}
\end{table}

%\lipsum[5] % Dummy text

\begin{equation}
\label{eq:emc}
e = mc^2
\end{equation}

%\lipsum[6] % Dummy text

%------------------------------------------------

\section{Discussion}

\subsection{Subsection One}

%\lipsum[7] % Dummy text

\subsection{Subsection Two}

%\lipsum[8] % Dummy text

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

\begin{thebibliography}{99} % Bibliography - this is intentionally simple in this template

\bibitem[Figueredo and Wolf, 2009]{Figueredo:2009dg}
Figueredo, A.~J. and Wolf, P. S.~A. (2009).
\newblock Assortative pairing and life history strategy - a cross-cultural
  study.
\newblock {\em Human Nature}, 20:317--330.
 
\end{thebibliography}

%----------------------------------------------------------------------------------------

\end{multicols}

\end{document}
